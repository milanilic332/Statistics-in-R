return(rnorm(3, mean = param, sd = c(0.5, 0.5, 0.5)))
}
MHA <- function(startvalue, iterations){
chain = array(dim = c(iterations + 1, 3))
chain[1, ] = startvalue
for (i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(posterior(proposal) - posterior(chain[i, ]))
if (runif(1) < probab){
chain[i + 1, ] = proposal
}else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
reps = 50000
trueA = 2
trueB = 10
trueSd = 10
sampleSize = 100
# Create x-values
x = ((-sampleSize/2):(sampleSize/2))
# Create y-values according to ax + b + N(0,sd) - noise
y = trueA*x + trueB + rnorm(n = sampleSize + 1, mean = 0, sd = trueSd)
# Plot the data to show how it is distributed
plot(x, y, main = "Test Data")
# Likelihood function
likelihood <- function(param){
a = param[1]
b = param[2]
sd = param[3]
pred = a*x + b
singleLikelihoods = dnorm(y, mean = pred, sd = sd, log = T)
sumSingle = sum(singleLikelihoods)
return(sumSingle)
}
# Prior distribution
prior <- function(param){
a = param[1]
b = param[2]
sd = param[3]
aPrior = dunif(a, min = -10, max = 20, log = T)
# Use this as an example chage sd = 20
bPrior = dnorm(b, sd = 1, log = T)
sdPrior = dnorm(sd, sd = 2, log = T)
return(aPrior + bPrior + sdPrior)
}
# Posterior distribution
posterior <- function(param){
return(likelihood(param) + prior(param))
}
# Proposal function (used for random walk)
proposalDist <- function(param){
return(rnorm(3, mean = param, sd = c(0.5, 0.5, 0.5)))
}
MHA <- function(startvalue, iterations){
chain = array(dim = c(iterations + 1, 3))
chain[1, ] = startvalue
for (i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(posterior(proposal) - posterior(chain[i, ]))
if (runif(1) < probab){
chain[i + 1, ] = proposal
}else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
reps = 50000
start = c(1, 0, 1)
# Run MHA
chain = MHA(start, reps)
# Burn first 1000 iterations for better results
burnIn = 1000
par(mfrow = c(2,3))
# Histograms and plots with thinning
hist(chain[seq(from = burnIn, to = reps, by = 10), 1], main = "Posterior of a", xlab="(true value, mean) = (red, blue)" )
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = 'blue')
abline(v = trueA, col = "red" )
hist(chain[seq(from = burnIn, to = reps, by = 10), 2], main = "Posterior of b", xlab="(true value, mean) = (red, blue)")
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), col = 'blue')
abline(v = trueB, col = "red" )
hist(chain[seq(from = burnIn, to = reps, by = 10), 3], main = "Posterior of sd", xlab="(true value, mean) = (red, blue)")
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 3]), col = 'blue')
abline(v = trueSd, col = "red" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 1], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of a" )
abline(h = trueA, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = "blue" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 2], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of b" )
abline(h = trueB, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), col = "blue" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 3], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of sd" )
abline(h = trueSd, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 3]), col = "blue" )
trueA = 2
trueB = 10
trueSd = 10
sampleSize = 100
# Create x-values
x = ((-sampleSize/2):(sampleSize/2))
# Create y-values according to ax + b + N(0,sd) - noise
y = trueA*x + trueB + rnorm(n = sampleSize + 1, mean = 0, sd = trueSd)
# Plot the data to show how it is distributed
plot(x, y, main = "Test Data")
# Likelihood function
likelihood <- function(param){
a = param[1]
b = param[2]
sd = param[3]
pred = a*x + b
singleLikelihoods = dnorm(y, mean = pred, sd = sd, log = T)
sumSingle = sum(singleLikelihoods)
return(sumSingle)
}
# Prior distribution
prior <- function(param){
a = param[1]
b = param[2]
sd = param[3]
aPrior = dunif(a, min = -10, max = 20, log = T)
# Use this as an example chage sd = 20
bPrior = dnorm(b, sd = 10, log = T)
sdPrior = dnorm(sd, sd = 2, log = T)
return(aPrior + bPrior + sdPrior)
}
# Posterior distribution
posterior <- function(param){
return(likelihood(param) + prior(param))
}
# Proposal function (used for random walk)
proposalDist <- function(param){
return(rnorm(3, mean = param, sd = c(0.5, 0.5, 0.5)))
}
MHA <- function(startvalue, iterations){
chain = array(dim = c(iterations + 1, 3))
chain[1, ] = startvalue
for (i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(posterior(proposal) - posterior(chain[i, ]))
if (runif(1) < probab){
chain[i + 1, ] = proposal
}else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
reps = 50000
start = c(1, 0, 1)
# Run MHA
chain = MHA(start, reps)
# Burn first 1000 iterations for better results
burnIn = 1000
par(mfrow = c(2,3))
# Histograms and plots with thinning
hist(chain[seq(from = burnIn, to = reps, by = 10), 1], main = "Posterior of a", xlab="(true value, mean) = (red, blue)" )
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = 'blue')
abline(v = trueA, col = "red" )
hist(chain[seq(from = burnIn, to = reps, by = 10), 2], main = "Posterior of b", xlab="(true value, mean) = (red, blue)")
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), col = 'blue')
abline(v = trueB, col = "red" )
hist(chain[seq(from = burnIn, to = reps, by = 10), 3], main = "Posterior of sd", xlab="(true value, mean) = (red, blue)")
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 3]), col = 'blue')
abline(v = trueSd, col = "red" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 1], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of a" )
abline(h = trueA, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = "blue" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 2], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of b" )
abline(h = trueB, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), col = "blue" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 3], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of sd" )
abline(h = trueSd, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 3]), col = "blue" )
# Draw our prediction line
par(mfrow = c(1, 1))
plot(x, y, main = "Test Data")
abline(trueB, trueA, col = "red")
abline(mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = "blue")
trueA = 2
trueB = 10
trueSd = 10
sampleSize = 100
# Create x-values
x = ((-sampleSize/2):(sampleSize/2))
# Create y-values according to ax + b + N(0,sd) - noise
y = trueA*x + trueB + rt(n = sampleSize + 1, df = 2)
# Plot the data to show how it is distributed
plot(x, y, main = "Test Data")
help(rt)
trueA = 2
trueB = 10
trueSd = 10
sampleSize = 100
# Create x-values
x = ((-sampleSize/2):(sampleSize/2))
# Create y-values according to ax + b + N(0,sd) - noise
y = trueA*x + trueB + sqrt(20)*rt(n = sampleSize + 1, df = 2)
help(rt)
# Plot the data to show how it is distributed
plot(x, y, main = "Test Data")
trueA = 2
trueB = 10
trueSd = 10
sampleSize = 100
# Create x-values
x = ((-sampleSize/2):(sampleSize/2))
# Create y-values according to ax + b + N(0,sd) - noise
y = trueA*x + trueB + sqrt(50)*rt(n = sampleSize + 1, df = 2)
help(rt)
# Plot the data to show how it is distributed
plot(x, y, main = "Test Data")
# Likelihood function
likelihood <- function(param){
a = param[1]
b = param[2]
sd = param[3]
pred = a*x + b
singleLikelihoods = dnorm(y, mean = pred, sd = sd, log = T)
sumSingle = sum(singleLikelihoods)
return(sumSingle)
}
# Prior distribution
prior <- function(param){
a = param[1]
b = param[2]
sd = param[3]
aPrior = dunif(a, min = -10, max = 20, log = T)
# Use this as an example chage sd = 20
bPrior = dnorm(b, sd = 10, log = T)
sdPrior = dnorm(sd, sd = 2, log = T)
return(aPrior + bPrior + sdPrior)
}
# Posterior distribution
posterior <- function(param){
return(likelihood(param) + prior(param))
}
# Proposal function (used for random walk)
proposalDist <- function(param){
return(rnorm(3, mean = param, sd = c(0.5, 0.5, 0.5)))
}
MHA <- function(startvalue, iterations){
chain = array(dim = c(iterations + 1, 3))
chain[1, ] = startvalue
for (i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(posterior(proposal) - posterior(chain[i, ]))
if (runif(1) < probab){
chain[i + 1, ] = proposal
}else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
reps = 50000
start = c(1, 0, 1)
# Run MHA
chain = MHA(start, reps)
# Burn first 1000 iterations for better results
burnIn = 1000
par(mfrow = c(2,3))
# Histograms and plots with thinning
hist(chain[seq(from = burnIn, to = reps, by = 10), 1], main = "Posterior of a", xlab="(true value, mean) = (red, blue)" )
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = 'blue')
abline(v = trueA, col = "red" )
hist(chain[seq(from = burnIn, to = reps, by = 10), 2], main = "Posterior of b", xlab="(true value, mean) = (red, blue)")
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), col = 'blue')
abline(v = trueB, col = "red" )
hist(chain[seq(from = burnIn, to = reps, by = 10), 3], main = "Posterior of sd", xlab="(true value, mean) = (red, blue)")
abline(v = mean(chain[seq(from = burnIn, to = reps, by = 10), 3]), col = 'blue')
abline(v = trueSd, col = "red" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 1], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of a" )
abline(h = trueA, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = "blue" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 2], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of b" )
abline(h = trueB, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), col = "blue" )
plot(chain[seq(from = burnIn, to = reps, by = 10), 3], type = "l", xlab="(true value, mean) = (red, blue)" , main = "Chain values of sd" )
abline(h = trueSd, col = "red" )
abline(h = mean(chain[seq(from = burnIn, to = reps, by = 10), 3]), col = "blue" )
# Draw our prediction line
par(mfrow = c(1, 1))
plot(x, y, main = "Test Data")
abline(trueB, trueA, col = "red")
abline(mean(chain[seq(from = burnIn, to = reps, by = 10), 2]), mean(chain[seq(from = burnIn, to = reps, by = 10), 1]), col = "blue")
# Multivariate Cauchy distribution
Cauchy <- function(x, x0 = c(50, 50), g = 1){
return(log((1/(2*pi))*(g/((x[1] - x0[1])^2 + (x[2] - x0[2])^2 + g^2)^1.5)))
}
# Proposal distribution - asymmetric
proposalDist <- function(param){
return(rnorm(2, mean = param + 1, sd = 5))
}
q <- function(x, xP){
x1 = dnorm(x[1], mean = xP[1] + 1, sd = 5)
x2 = dnorm(x[2], mean = xP[2] + 1, sd = 5)
return(log(x1*x2))
}
# Metropolis-Hastings algorithm
MA <- function(startValue, iterations){
chain = matrix(data = NA, ncol = 2, nrow = iterations + 1)
chain[1, ] = startValue
for(i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(Cauchy(proposal) + q(chain[i, ], proposal) - Cauchy(chain[i, ]) - q(proposal, chain[i, ]))
if(runif(1) < probab){
chain[i + 1, ] = proposal
}
else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
# Start values
startValue = c(10, 10)
iterations = 50000
# Run MA
chain = MA(startValue, iterations)
# Burn first 5000 values
burnIn = 5000
# Histograms (with thinning)
par(mfrow = c(1, 2))
hist(chain[, 1])
n1 = length(chain[seq(from = burnIn, to = iterations, by = 10), 1])
k1 = floor(log(n1, base = 2)) + 1
d1 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 1]))/k1
n2 = length(chain[seq(from = burnIn, to = iterations, by = 10), 2])
k2 = floor(log(n2, base = 2)) + 1
d2 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 2]))/k2
sortedChain = matrix(data = NA, ncol = 2, nrow = n1)
sortedChain[, 1] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 1])
sortedChain[, 2] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 2])
br1 = sortedChain[, 1][1] + 0:k1*d1
br2 = sortedChain[, 2][1] + 0:k2*d2
hist(sortedChain[, 1], breaks = br1, main = "Distribution of x[1]")
# Multivariate Cauchy distribution
Cauchy <- function(x, x0 = c(50, 50), g = 1){
return(log((1/(2*pi))*(g/((x[1] - x0[1])^2 + (x[2] - x0[2])^2 + g^2)^1.5)))
}
# Proposal distribution - asymmetric
proposalDist <- function(param){
return(rnorm(2, mean = param + 1, sd = 5))
}
q <- function(x, xP){
x1 = dnorm(x[1], mean = xP[1] + 1, sd = 5)
x2 = dnorm(x[2], mean = xP[2] + 1, sd = 5)
return(log(x1*x2))
}
# Metropolis-Hastings algorithm
MA <- function(startValue, iterations){
chain = matrix(data = NA, ncol = 2, nrow = iterations + 1)
chain[1, ] = startValue
for(i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(Cauchy(proposal) + q(chain[i, ], proposal) - Cauchy(chain[i, ]) - q(proposal, chain[i, ]))
if(runif(1) < probab){
chain[i + 1, ] = proposal
}
else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
# Start values
startValue = c(10, 10)
iterations = 50000
# Run MA
chain = MA(startValue, iterations)
# Burn first 5000 values
burnIn = 5000
# Histograms (with thinning)
par(mfrow = c(1, 2))
n1 = length(chain[seq(from = burnIn, to = iterations, by = 10), 1])
k1 = floor(log(n1, base = 2)) + 1
d1 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 1]))/k1
n2 = length(chain[seq(from = burnIn, to = iterations, by = 10), 2])
k2 = floor(log(n2, base = 2)) + 1
d2 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 2]))/k2
sortedChain = matrix(data = NA, ncol = 2, nrow = n1)
sortedChain[, 1] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 1])
sortedChain[, 2] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 2])
br1 = sortedChain[, 1][1] + 0:k1*d1
br2 = sortedChain[, 2][1] + 0:k2*d2
hist(sortedChain[, 1], breaks = br1, main = "Distribution of x[1]")
hist(sortedChain[, 2], breaks = br2, main = "Distribution of x[2]")
# Plot chains
par(mfrow = c(1, 2))
plot(chain[seq(from = burnIn, to = iterations, by = 10), 1], type = 'l')
plot(chain[seq(from = burnIn, to = iterations, by = 10), 2], type = 'l')
# Plot chains together
par(mfrow = c(1, 1))
plot(chain[seq(from = burnIn, to = iterations, by = 10), 1], chain[seq(from = burnIn, to = iterations, by = 10), 2], type = 'l', xlab = "x[2] values", ylab = "x[1] values", col = "coral1")
# Multivariate Cauchy distribution
Cauchy <- function(x, x0 = c(50, 50), g = 1){
return(log((1/(2*pi))*(g/((x[1] - x0[1])^2 + (x[2] - x0[2])^2 + g^2)^1.5)))
}
# Proposal distribution - asymmetric
proposalDist <- function(param){
return(rnorm(2, mean = param + 1, sd = 5))
}
q <- function(x, xP){
x1 = dnorm(x[1], mean = xP[1] + 1, sd = 5)
x2 = dnorm(x[2], mean = xP[2] + 1, sd = 5)
return(log(x1*x2))
}
# Metropolis-Hastings algorithm
MA <- function(startValue, iterations){
chain = matrix(data = NA, ncol = 2, nrow = iterations + 1)
chain[1, ] = startValue
for(i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(Cauchy(proposal) + q(chain[i, ], proposal) - Cauchy(chain[i, ]) - q(proposal, chain[i, ]))
if(runif(1) < probab){
chain[i + 1, ] = proposal
}
else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
# Start values
startValue = c(10, 10)
iterations = 50000
# Run MA
chain = MA(startValue, iterations)
# Burn first 5000 values
burnIn = 5000
# Histograms (with thinning)
par(mfrow = c(1, 2))
n1 = length(chain[seq(from = burnIn, to = iterations, by = 10), 1])
k1 = floor(log(n1, base = 2)) + 1
d1 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 1]))/k1
n2 = length(chain[seq(from = burnIn, to = iterations, by = 10), 2])
k2 = floor(log(n2, base = 2)) + 1
d2 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 2]))/k2
sortedChain = matrix(data = NA, ncol = 2, nrow = n1)
sortedChain[, 1] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 1])
sortedChain[, 2] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 2])
br1 = sortedChain[, 1][1] + 0:k1*d1
br2 = sortedChain[, 2][1] + 0:k2*d2
hist(sortedChain[, 1], breaks = br1, main = "Distribution of x[1]")
hist(sortedChain[, 2], breaks = br2, main = "Distribution of x[2]")
# Plot chains
par(mfrow = c(1, 2))
plot(chain[seq(from = burnIn, to = iterations, by = 10), 1], type = 'l')
plot(chain[seq(from = burnIn, to = iterations, by = 10), 2], type = 'l')
# Plot chains together
par(mfrow = c(1, 1))
plot(chain[seq(from = burnIn, to = iterations, by = 10), 1], chain[seq(from = burnIn, to = iterations, by = 10), 2], type = 'l', xlab = "x[2] values", ylab = "x[1] values", col = "coral1")
# Multivariate Cauchy distribution
Cauchy <- function(x, x0 = c(50, 50), g = 1){
return(log((1/(2*pi))*(g/((x[1] - x0[1])^2 + (x[2] - x0[2])^2 + g^2)^1.5)))
}
# Proposal distribution - asymmetric
proposalDist <- function(param){
return(rnorm(2, mean = param + 1, sd = 5))
}
q <- function(x, xP){
x1 = dnorm(x[1], mean = xP[1] + 1, sd = 5)
x2 = dnorm(x[2], mean = xP[2] + 1, sd = 5)
return(log(x1*x2))
}
# Metropolis-Hastings algorithm
MA <- function(startValue, iterations){
chain = matrix(data = NA, ncol = 2, nrow = iterations + 1)
chain[1, ] = startValue
for(i in 1:iterations){
proposal = proposalDist(chain[i, ])
probab = exp(Cauchy(proposal) + q(chain[i, ], proposal) - Cauchy(chain[i, ]) - q(proposal, chain[i, ]))
if(runif(1) < probab){
chain[i + 1, ] = proposal
}
else{
chain[i + 1, ] = chain[i, ]
}
}
return(chain)
}
# Start values
startValue = c(10, 10)
iterations = 50000
# Run MA
chain = MA(startValue, iterations)
# Burn first 5000 values
burnIn = 5000
# Histograms (with thinning)
par(mfrow = c(1, 2))
n1 = length(chain[seq(from = burnIn, to = iterations, by = 10), 1])
k1 = floor(log(n1, base = 2)) + 1
d1 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 1]))/k1
n2 = length(chain[seq(from = burnIn, to = iterations, by = 10), 2])
k2 = floor(log(n2, base = 2)) + 1
d2 = diff(range(chain[seq(from = burnIn, to = iterations, by = 10), 2]))/k2
sortedChain = matrix(data = NA, ncol = 2, nrow = n1)
sortedChain[, 1] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 1])
sortedChain[, 2] = sort(chain[seq(from = burnIn, to = iterations, by = 10), 2])
br1 = sortedChain[, 1][1] + 0:k1*d1
br2 = sortedChain[, 2][1] + 0:k2*d2
hist(sortedChain[, 1], breaks = br1, main = "Distribution of x[1]")
hist(sortedChain[, 2], breaks = br2, main = "Distribution of x[2]")
# Plot chains
par(mfrow = c(1, 2))
plot(chain[seq(from = burnIn, to = iterations, by = 10), 1], type = 'l')
plot(chain[seq(from = burnIn, to = iterations, by = 10), 2], type = 'l')
# Plot chains together
par(mfrow = c(1, 1))
plot(chain[seq(from = burnIn, to = iterations, by = 10), 1], chain[seq(from = burnIn, to = iterations, by = 10), 2], type = 'l', xlab = "x[2] values", ylab = "x[1] values", col = "coral1")
